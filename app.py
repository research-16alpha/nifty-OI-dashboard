import streamlit as st
import pandas as pd
import json
import os
import time

st.set_page_config(
    page_title="NIFTY OI Dashboard",
    layout="wide"
)

# ---------------------------
# PAGE NAVIGATION
# ---------------------------
page = st.sidebar.radio(
    "Navigation",
    ["üè† Home", "üìä Strategy Dashboard"]
)

# ---------------------------
# HOME PAGE
# ---------------------------
if page == "üè† Home":
    st.title("üè† Welcome to the NIFTY OI Strategy Dashboard")

    st.markdown("""
    ## üìò Overview

    This dashboard showcases a systematic options trading strategy based on **Open Interest (OI) dynamics** across NIFTY option chain data.  
    All backtests shown here are **pre-processed locally** using historical option chain snapshots and then made available for analysis through this application.

    ---
    ## üìä What is Open Interest (OI)?

    **Open Interest (OI)** represents the total number of outstanding (open) contracts at a particular strike price.  
    It increases when traders open new positions and decreases when positions are closed.

    Rising OI suggests:
    - Fresh positions
    - Increasing participation
    - Momentum building  

    Falling OI suggests:
    - Profit booking
    - Weakness in trend
    - Possible reversal

    ---

    ## üéØ Strategy Logic (High-Level)

    This strategy attempts to capture **short-term momentum** created by changes in OI.

    A trade is entered when:
    - **OI increases** in the option to be bought  
    - **OI decreases** in the opposite option  
    - The option price (LTP) rises steadily over several snapshots  

    This combination suggests *fresh long positions* are entering aggressively.

    ---

    ## ‚è± How the Data Works (Snapshots)

    NSE updates option chain every **3 minutes**.

    Each **snapshot** in our dataset is one scrape of the entire chain.

    So:
    - Snapshot 0 ‚Üí time T  
    - Snapshot 1 ‚Üí time T + 3 min  
    - Snapshot 2 ‚Üí time T + 6 min  

    Snapshots help detect:
    - Price momentum  
    - OI shifts  
    - Underlying price moves  

    ---

    ## üîÅ Cooldown Period

    After exiting a trade, the strategy waits for *N snapshots* before entering again.

    Purpose:
    - Avoid over-trading  
    - Avoid re-entering after whipsaws  
    - Force clean setups  

    ---

    ## ‚è≥ Minimum Holding Period

    Each trade must stay open for **at least N snapshots**.

    This avoids:
    - Quick exits  
    - Noise  
    - Flip-flopping  

    ---

    ## ‚öôÔ∏è Backtest Engine Summary

    For every strategy:
    - Signals are generated using OI + LTP momentum  
    - Backtest runs through all snapshots  
    - Equity curve is created  
    - Stats calculated: CAGR, Sharpe, Drawdown, etc.  
    - Results saved inside `backtest_results/`  

    This dashboard loads them and lets you:
    - View strategy performance  
    - Download trade logs  
    - Compare optimized strategies  

    ---

    ## üßæ Disclaimer

    This is a **research tool**, not investment advice.  
    Historical results do not guarantee future returns.  

    Use responsibly.
    """)
    st.stop()


# ======================================================
# BASIC CONFIG
# ======================================================

BACKTEST_ROOT = "backtest_results"           # folder generated by final_code.py
SUMMARY_CSV = "optimization_results.csv"     # file generated by final_code.py

st.set_page_config(
    page_title="Options Backtest Dashboard",
    layout="wide"
)

st.title("üìà Options Backtest Dashboard")
st.caption("View any one strategy from your precomputed backtests.")



# ======================================================
# HELPERS
# ======================================================

@st.cache_data
def load_summary():
    """Load optimization_results.csv."""
    df = pd.read_csv(SUMMARY_CSV)
    return df


@st.cache_data
def list_strategy_folders():
    """List all strategy folders under /backtest_results."""
    if not os.path.isdir(BACKTEST_ROOT):
        return []
    return sorted([
        name for name in os.listdir(BACKTEST_ROOT)
        if os.path.isdir(os.path.join(BACKTEST_ROOT, name))
    ])


@st.cache_data
def load_strategy_data(folder_name: str):
    """Load equity.csv, trades.csv, and stats.json from a strategy folder."""
    folder_path = os.path.join(BACKTEST_ROOT, folder_name)

    equity_path = os.path.join(folder_path, "equity.csv")
    trades_path = os.path.join(folder_path, "trades.csv")
    stats_path = os.path.join(folder_path, "stats.json")

    if not os.path.exists(equity_path) or not os.path.exists(trades_path):
        raise FileNotFoundError(f"Missing files in {folder_path}")

    # Equity
    equity = pd.read_csv(equity_path)
    if "TIMESTAMP" in equity.columns:
        equity["TIMESTAMP"] = pd.to_datetime(equity["TIMESTAMP"])

    # Trades
    trades = pd.read_csv(trades_path)
    for col in ["entry_datetime", "exit_datetime"]:
        if col in trades.columns:
            trades[col] = pd.to_datetime(trades[col])

    # Stats JSON
    stats = {}
    if os.path.exists(stats_path):
        with open(stats_path, "r") as f:
            stats = json.load(f)

    return equity, trades, stats


def params_to_folder_name(sl, cd, mh):
    """Match folder naming from final_code.py."""
    return f"SL_{sl}_CD_{cd}_MH_{mh}"



# ======================================================
# LOAD GLOBAL DATA
# ======================================================

try:
    opt_df = load_summary()
except Exception as e:
    st.error(f"Error loading optimization summary CSV: {e}")
    st.stop()

strategy_folders = list_strategy_folders()
if not strategy_folders:
    st.warning("No strategy folders found in backtest_results/")
    st.stop()

# Extract unique parameter values
unique_sl = sorted(opt_df["STOP_LOSS_PCT"].unique())
unique_cd = sorted(opt_df["COOLDOWN"].unique())
unique_mh = sorted(opt_df["MIN_HOLD_SNAPS"].unique())



# ======================================================
# SIDEBAR ‚Äì STRATEGY SELECTION
# ======================================================

st.sidebar.header("Strategy Selection")

mode = st.sidebar.radio(
    "Select strategy by:",
    ["Parameters", "Optimization Metric"],
    index=0
)

sidebar_status = st.sidebar.empty()

selected_folder = None
selected_row = None



# ======================================================
# MODE 1 ‚Äî SELECT BY PARAMETERS
# ======================================================

if mode == "Parameters":
    st.sidebar.subheader("Choose Parameter Combination")

    sl = st.sidebar.selectbox("Stop Loss %", unique_sl)
    cd = st.sidebar.selectbox("Cooldown (snapshots)", unique_cd)
    mh = st.sidebar.selectbox("Min Hold (snapshots)", unique_mh)

    run_btn = st.sidebar.button("üöÄ Backtest ")

    if run_btn:
        with st.sidebar:
            with st.spinner("Running backtest... "):
                time.sleep(3)

        # Find exact row in opt_df
        mask = (
            (opt_df["STOP_LOSS_PCT"] == sl) &
            (opt_df["COOLDOWN"] == cd) &
            (opt_df["MIN_HOLD_SNAPS"] == mh)
        )

        if not mask.any():
            st.error("No matching strategy found for these parameters.")
            st.stop()

        selected_row = opt_df[mask].iloc[0]
        selected_folder = params_to_folder_name(sl, int(cd), int(mh))

        sidebar_status.success(f"Loaded Strategy: {selected_folder}")



# ======================================================
# MODE 2 ‚Äî SELECT BY OPTIMIZATION METRIC
# ======================================================

if mode == "Optimization Metric":
    st.sidebar.subheader("Choose Optimization Metric")

    criterion = st.sidebar.selectbox(
        "Optimization Metric",
        [
            "Best CAGR",
            "Best Sharpe Ratio",
            "Best Total Return",
            "Min Drawdown (absolute)",
            "Best Calmar Ratio"
        ]
    )

    run_btn = st.sidebar.button("üöÄ Pick Best Strategy")

    if run_btn:
        with st.sidebar:
            with st.spinner("Selecting best strategy... "):
                time.sleep(3)

        if criterion == "Best CAGR":
            idx = opt_df["cagr_pct"].idxmax()
        elif criterion == "Best Sharpe Ratio":
            idx = opt_df["sharpe_ratio"].idxmax()
        elif criterion == "Best Total Return":
            idx = opt_df["total_return_pct"].idxmax()
        elif criterion == "Min Drawdown (absolute)":
            idx = opt_df["max_drawdown_pct"].abs().idxmin()
        elif criterion == "Best Calmar Ratio":
            idx = opt_df["calmar_ratio"].idxmax()
        else:
            idx = opt_df["total_return_pct"].idxmax()

        selected_row = opt_df.loc[idx]

        sl = selected_row["STOP_LOSS_PCT"]
        cd = int(selected_row["COOLDOWN"])
        mh = int(selected_row["MIN_HOLD_SNAPS"])

        selected_folder = params_to_folder_name(sl, cd, mh)

        sidebar_status.success(f"Loaded Strategy: {selected_folder}")



# ======================================================
# MAIN PANEL ‚Äì DISPLAY STRATEGY
# ======================================================

if selected_folder is None:
    st.info("Choose parameters or an optimization metric, then click BACKTEST.")
    st.stop()

folder_path = os.path.join(BACKTEST_ROOT, selected_folder)
if not os.path.isdir(folder_path):
    st.error(f"Strategy folder not found: {selected_folder}")
    st.stop()

# Load data
try:
    equity_df, trades_df, stats = load_strategy_data(selected_folder)
except Exception as e:
    st.error(f"Error reading strategy data: {e}")
    st.stop()

st.subheader(f"üìÅ Strategy: `{selected_folder}`")

# Show Parameters
st.markdown("### üîß Parameters")
st.json({
    "STOP_LOSS_PCT": sl,
    "COOLDOWN": cd,
    "MIN_HOLD_SNAPS": mh
})


# ======================================================
# PERFORMANCE METRICS
# ======================================================

st.markdown("### üìä Performance Metrics")

def s(key, default=0):
    return stats.get(key, default)

c1, c2, c3, c4, c5 = st.columns(5)

c1.metric("Total Return %", f"{s('total_return_pct'):.2f}")
c2.metric("CAGR %", f"{s('cagr_pct'):.2f}")
c3.metric("Max DD %", f"{s('max_drawdown_pct'):.2f}")
c4.metric("Sharpe", f"{s('sharpe_ratio'):.2f}")
c5.metric("Trades", f"{int(s('num_trades', len(trades_df)))}")


# ======================================================
# EQUITY CURVE
# ======================================================

st.markdown("### üìà Equity Curve")

if "TIMESTAMP" in equity_df.columns:
    plot_df = equity_df.set_index("TIMESTAMP")["EQUITY"]
    st.line_chart(plot_df, use_container_width=True)
else:
    st.warning("TIMESTAMP column missing in equity.csv.")


# ======================================================
# TRADES TABLE + DOWNLOAD
# ======================================================

st.markdown("### üìë Trades (First 200 shown)")

st.dataframe(trades_df.head(200), use_container_width=True)

col_a, col_b = st.columns(2)

with col_a:
    st.download_button(
        "üì• Download Full Trades CSV",
        trades_df.to_csv(index=False).encode("utf-8"),
        file_name=f"{selected_folder}_trades.csv",
        mime="text/csv",
    )

with col_b:
    st.download_button(
        "üì• Download Equity CSV",
        equity_df.to_csv(index=False).encode("utf-8"),
        file_name=f"{selected_folder}_equity.csv",
        mime="text/csv",
    )


# ======================================================
# FULL RAW STATS
# ======================================================

with st.expander("üîç Full Stats JSON"):
    st.json(stats)
